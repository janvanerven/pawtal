//! OIDC / OAuth2 client helpers.
//!
//! This module handles the three legs of the authorization code flow:
//!   1. Discover the provider's endpoints via `/.well-known/openid-configuration`
//!   2. Build the redirect URL that sends the browser to the IdP
//!   3. Exchange the authorization code for tokens and fetch user info
//!
//! All network calls go through a caller-supplied `reqwest::Client` so that
//! connection pooling is controlled at the call site (typically AppState).

use reqwest::Client;
use serde::{Deserialize, Serialize};

use crate::config::Config;
use crate::error::{AppError, AppResult};

/// Subset of the OpenID Connect discovery document we actually use.
/// The full spec (RFC 8414) has many more fields; we only decode what we need
/// so that provider-specific extras don't cause deserialization failures.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct OidcDiscovery {
    pub authorization_endpoint: String,
    pub token_endpoint: String,
    pub userinfo_endpoint: String,
}

/// Token response from the provider's token endpoint (RFC 6749 §5.1).
#[derive(Debug, Deserialize)]
pub struct TokenResponse {
    pub access_token: String,
    pub token_type: String,
    pub expires_in: Option<u64>,
    pub id_token: Option<String>,
}

/// Normalized user identity returned by the userinfo endpoint.
/// Fields beyond `sub` are optional because not all providers include them.
#[derive(Debug, Deserialize)]
pub struct UserInfo {
    /// Provider-scoped unique identifier — stable and opaque.
    pub sub: String,
    pub email: Option<String>,
    pub preferred_username: Option<String>,
    pub name: Option<String>,
}

/// Fetches and deserializes the OIDC discovery document from
/// `{issuer}/.well-known/openid-configuration`.
///
/// Returns an error if the network request fails or the document cannot be
/// parsed as a valid `OidcDiscovery`.
pub async fn discover_oidc(client: &Client, issuer_url: &str) -> AppResult<OidcDiscovery> {
    // Strip any trailing slash so we always produce exactly one slash before
    // the well-known path.
    let discovery_url = format!(
        "{}/.well-known/openid-configuration",
        issuer_url.trim_end_matches('/')
    );

    let discovery = client
        .get(&discovery_url)
        .send()
        .await
        .map_err(|e| AppError::Internal(format!("OIDC discovery request failed: {e}")))?
        .json::<OidcDiscovery>()
        .await
        .map_err(|e| AppError::Internal(format!("OIDC discovery parse failed: {e}")))?;

    Ok(discovery)
}

/// Builds the authorization URL that the browser should be redirected to.
///
/// Uses `response_type=code` (authorization code flow) and requests the
/// `openid email profile` scopes. The `state` parameter is an opaque value
/// generated by the caller; it should be stored in the user's session and
/// verified when the callback arrives to guard against CSRF.
pub fn build_auth_url(discovery: &OidcDiscovery, config: &Config, state: &str) -> String {
    let redirect_uri = format!(
        "{}/api/auth/callback",
        config.base_url.trim_end_matches('/')
    );

    // Build the query string manually so we don't need an extra URL-building
    // dependency. All values here are either static strings or already-encoded
    // config values; the only runtime value that needs encoding is `state`.
    format!(
        "{}?response_type=code&client_id={}&redirect_uri={}&scope=openid+email+profile&state={}",
        discovery.authorization_endpoint,
        urlencoding::encode(&config.oauth2_client_id),
        urlencoding::encode(&redirect_uri),
        urlencoding::encode(state),
    )
}

/// Exchanges an authorization code for an access token (and optionally an
/// ID token) by posting to the provider's token endpoint.
///
/// Uses HTTP Basic authentication with the client credentials, which is the
/// most interoperable method across providers.
pub async fn exchange_code(
    client: &Client,
    discovery: &OidcDiscovery,
    config: &Config,
    code: &str,
) -> AppResult<TokenResponse> {
    let redirect_uri = format!(
        "{}/api/auth/callback",
        config.base_url.trim_end_matches('/')
    );

    let params = [
        ("grant_type", "authorization_code"),
        ("code", code),
        ("redirect_uri", redirect_uri.as_str()),
    ];

    let response = client
        .post(&discovery.token_endpoint)
        .basic_auth(&config.oauth2_client_id, Some(&config.oauth2_client_secret))
        .form(&params)
        .send()
        .await
        .map_err(|e| AppError::Internal(format!("Token exchange request failed: {e}")))?;

    if !response.status().is_success() {
        let status = response.status();
        let body = response
            .text()
            .await
            .unwrap_or_else(|_| "<unreadable body>".into());
        return Err(AppError::Internal(format!(
            "Token endpoint returned {status}: {body}"
        )));
    }

    response
        .json::<TokenResponse>()
        .await
        .map_err(|e| AppError::Internal(format!("Token response parse failed: {e}")))
}

/// Fetches the user's claims from the userinfo endpoint using a Bearer token.
pub async fn fetch_userinfo(
    client: &Client,
    discovery: &OidcDiscovery,
    access_token: &str,
) -> AppResult<UserInfo> {
    let response = client
        .get(&discovery.userinfo_endpoint)
        .bearer_auth(access_token)
        .send()
        .await
        .map_err(|e| AppError::Internal(format!("Userinfo request failed: {e}")))?;

    if !response.status().is_success() {
        let status = response.status();
        return Err(AppError::Internal(format!(
            "Userinfo endpoint returned {status}"
        )));
    }

    response
        .json::<UserInfo>()
        .await
        .map_err(|e| AppError::Internal(format!("Userinfo parse failed: {e}")))
}
